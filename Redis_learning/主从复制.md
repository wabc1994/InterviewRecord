[TOC]



# redis  主从复制 如何实现

主从复制是Redis中高可用的基础, 那么主从复制是如何实现的呢？主节点和从节点的之间的数据如何进行同步

主从复制也叫做读写分类，镜像问题是关于MySQL,主要是redis也同样是 rdb文件来搞的，类似于持久化方案里面，然后从数据执行rdb文件即可

> 如何事项MySQL 的读写分离？MySQL 主从复制原理是啥？如何解决MySQL 主从同步的延时问题


## mysql 存在的问题

1. 主库宕机后，数据可能丢失
2. 主从同步延迟

## MySQL数据库主从同步延迟产生的原因
- MySQL的主从复制都是单线程操作，主库对多有DDL(data definition language）数据库定义语言和DML(data manipulation language)数据操作语言)产生的日志写入binlog,

- 由于binlog 是顺序写，所以效率很高，

- Slave 的SQL Thread 线程将主库的DDL和DML操作放在slave当中重放，由于DML和DDL的I/O操作是随机的，不是顺序的，成本高很多的

- 另一方面，由于SQL Thread 也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL Thread 所能处理的速度，或者slave中有大型query语句产生了锁等待那么延时就产生了。


常见的原因：Master负载过高、Slave负载过高、网络延迟、机器性能太低、MySQL配置不合理。


## 如何解决mysql 主从同步延迟

最简单的减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行。还有就是主库是写，对数据安全性较高，比如 sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也 可以设置为0来提高sql的执行效率。另外就是使用比主库更好的硬件设备作为slave。


改进：mysql-5.6.3已经支持了多线程的主从复制。原理和丁奇的类似，丁奇的是以表做多线程，Oracle使用的是以数据库(schema)为单位做多线程，不同的库可以使用不同的复制线程。

## 三个阶段

1. 连接建立阶段 （主要是通过网络通信机制）
    - slave of masterip port 设置主服务器的地址和端口
    - 建立套接字连接 
    - 发送ping命令
2. 数据同步阶段
    - 全量复制(full resynchronization)
    - 部分复制(partial resynchronization)
3. 命令传播阶段

### 连接建立阶段

该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。主要是从节点执行slave of master ip master port 主要是从节点进行操作



### 数据同步阶段

建立连接后，如果从节点要同步数据， 就要向主节点发送PSYNC命令给master node.

如果这是slave node 第一次连接到master node, 那么就进行一次全量复制。

这个过程是怎么完成的呢？

> Master 启动一个后台线程，执行bsave 命令，生成一个RDB快照文件, 同时将client 新收到的写命令缓存到内存中，RDB文件完成后，master 会将这个RDB发送给slave ，slave会先写入本地磁盘，然后再从本地磁盘加载到内存，接着master 会将缓存中的写命令发送到slave ， slave 也会同步这部分数据。
>
> slave node 如果跟master node 在这个过程当中，存在网络故障，断开了连接，会自动重连，这次自动重新连接后，master node 和slave node 直接只会进行部分复制。

主要是借助持久化机制RDF和内存缓冲机制完成这个过程。

数据同步过程图如下所示该种情况

![](https://github.com/wabc1994/InterviewRecord/blob/master/Redis_learning/picture/20180623163859718.png)



在同步的过程中，会有新的写命令修改主数据库中的数据，master node 是使用了复制缓存区一个概念记录从现在开始执行的所有写命令，

## 部分复制是如何实现？

由于全量复制在主节点数据量比较打的时候效率很低， 因此Redis2.8后面开始提供部分复制， 用于处理网络中断时的数据同步问题。(网络中断过程还是会受到不少写命令的， 所有在后面都要讲)

**为何需要部分复制？**
>全量复制SYNC是一个非常耗费资源的操作，每次都是从完全复制也是很没必要的一个过程，

PSYNC 部分复制的关键东西

1. 复制偏移量： master和slave服务器都有一个复制偏移量，记录当前同步记录的位置，记录复制的位置offset等信息


2. 复制积压缓冲区 : 用于记录网络连接中断过程中服务器接受到的写命令操作,是一个先进入先出去的固定大小的队列，一般都是设置为1MB，如果主从服务器数据库保持一致的话，那么主服务器和从服务器的offset 是一样大小的情况，如果从服务器的偏移量少于主服务器的偏移量的，
 那么代表从服务器是需要进行增量复制的，将主服务器后面的offset后面的数据发送给客户端


3. 服务器运行ID(runid): master server 唯一标识， 断开后重连，从服务器向主服务器发送信息的同时



### 什么样的情况开启增量复制

网络连接中断后，slave server 将尝试重新连接master server。**重新连接上之后服务器不一定是之前断网之前的那台服务器了** 当满足下列条件了，重新连接操作后进行增联同步复制

1. Slave server 记录的master 服务器和当前连接的master 服务器id一样

2. slave server 的复制偏移量比master server的偏移量靠前，比如slave server 是1000， master server 是11000

3. slave server 的复制偏移量所指定的数据仍然保存在主服务器的内存缓冲队列中，如果服务器,从服务器和主服务器的复制偏移量做一个差值，如果差值这部分对应的东西还在复制积压缓冲区当中的话，

我们可以直接开启部分复制的功能，否则的话就是用全量复制，断线后服务器要同时给主服务器发送run id 和自己的复制偏移量给master 



### 命令传播阶段

主要是主服务器向从服务器发送写命令，保证数据的一致性； 除了发送写命令，主从节点还维持着心跳机制：PING 和REPLCONF ACK。

# 应用带来的问题

1. 读写分离带来的问题

   数据不一致性问题，数据过期问题， 故障切换问题，复制超时问题 ，复制中断

2. 缺点明显，**故障恢复无法自动化**和缺乏容错能力，写操作无法负载均衡，存储能力受到限制

3. 一般在生产环境中使用得比较少， 主要是后面的那几种， 集群和哨兵机制使用得比较多， 但是也要花费很多时间来学习主从复制， 因为主从复制是后面两个的基础。

# 参考链接

[主从复制](https://www.cnblogs.com/kismetv/p/9236731.html)

[参考一](https://blog.csdn.net/liupeifeng3514/article/details/80791017)

《Redis设计与实现》读书笔记