
# 调度
六种调度策略，五种调度类，三种调度实体


## 进程的几种态

Linux中的process主要有以下几个方面
- Task_ Running 有两方面的意思，第一是可执行的(但还没有获得cpu),第二是可执行的并且获得cpu的执行


## 进程的结构体
task_struct 
包含各种字段，其中与调度相关的主要有以下几个

1. priority 优先级
2. struct sched_entity se 对应的调度实体
3. struct sched_class 对应的调度类
4. 

## 进程的分类

- 实时进程

就是要你即刻处理，换言之，在容忍的范围内得马上到处理，当然优先级要高，并且能够抢占其他进程。


- 普通进程


从时间片是否有剩余来划分，时间片还有，获得cpu执行，则称为active process ,否则expire process

- 活动进程
- 过期进程



## 进程优先级
为什么需要有不同的进程优先级?

不同进程具有不同的优先级的，调度算法也不相同

Linux 采用了两种不同的优先级

1. 使用nice 值:越大的nice值意味着更低的优先级.(-19~20)

2. 实时优先级：可配置，越高意味着进程优先级越高。

>任何实时的进程优先级都高于普通的进程，因此上面的两种优先级范围处于互不相交的范畴 


## rq
 rq 是当前CPU上就绪进程所组织的队列，这个结构体记录每个调度器类的队里状态，rq结构体中有cfs_rq和rt_rq两个子结构，分别描述了该CPU上fair类型和rt类型进程的信息。

# 实时进程调度

实时进程的两种调度策略

1. SCHED_FIFO 先入先出调度算法，相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务


2. SCHED_RR  轮流调度算法，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。时间片轮转调度，每个实时任务划分一个时间片，时间片用完会切换到其他任务执行。


对应的调度器类为rt_sched_class,对应的调度实体sched_rt_entity ，每个调度类都有自己的就绪队列


## FIFO

相同优先级的服从先进先来的服务策略，并且支持高优先级

## ROUND_ROBIN


# 普通进程调度

普通进程调度难度大于实时进程，普通进程的调度实体sched_entity 

## O(N)
遍历所有的进程信息，所有时间复杂度该O(n)

## O(1)调度器

Linux从2.5版本开始引入一种名为O(1)的调度器，解决为进程分配新的时间片问题，之前为每一个**进程分配时间片(TIME sharing)**

## 电梯调度算法



## CFS 完全公平调度算法 

该调度算法的基础是电梯调度算法


后在2.6版本中将公平的的调度概念引入了调度程序，代替之前的调度器，称为CFS算法（完全公平调度算法）。不再使用时间片这个概念，而是使用了**处理器使用比重**


struct cfs_rq *cfs_rq 

### CFS实现

### 红黑树

### vrunntime 
进程获得CPU的累积运行时间称为虚拟运行时间，

# 参考链接
[Linux进程调度器概述](https://blog.csdn.net/gatieme/article/details/51699889)

[](https://vinoit.me/2016/08/26/linux-kernel-note-process-scheduling/#%E6%A6%82%E8%A7%88)
