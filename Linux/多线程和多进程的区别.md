# 主要从几个点来回答
1. 作用，进程是资源分配的单位，进程具有独立的地址空间，而线程是没有的；线程是系统进行调度的基本单位
2. 上下文切换的开销，进程要远远大于线程
3. 线程通信代价低，进程通信代价高
4. 线程没有独立的地址空间，进程有独立的地址空间
5. 从属关系，一个进程可以有多个线程，至少有一个


- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
- 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
- CPU分给线程，即真正在CPU上运行的是线程。

## 上下文切换
上下文切换只能发生在内核态中。
### 进程切换
1. 进程上下文包含了进程执行所需要的所有信息
    - **用户地址空间**：程序代码段，数据，用户堆栈
    - **控制信息**：进程描述符，内核栈
    - **硬件上下文**：CU
    
**关于内核栈这里面要联系下内核态和用户态**

> 每个进程在创建的时候都有一个进程stack和内核stack，

2. 进程切换分为三步

- 切换页目录以使用新的地址空间，切换不同进程的地址空间
- 切换内核stack，由用户进程stack转化为内核stack，由用户态进出入内核态
- 切换硬件上下文，一些程序执行的环境


**什么叫做硬件上下文**

>尽管每个进程可以拥有属于自己的地址空间，但是所有进程必须共享CPU寄存器，因此，在恢复一个进程的执行前，内核必须确保每个寄存器装入了挂起进程时的值
进程恢复执行前必须装入寄存器的那一组数据成为硬件上下文。进程切换可以这样表述：保存将要切换出的进程的硬件上下文，用将要切换进来的进程的硬件上下文来代替。linux2.6使用软件进行进程切换。进程切换只发生在内核态




### 线程切换

上下文切换的定义
> 上下文切换就是从当前执行任务切换到另一个任务执行的过程。但是，为了确保下次能从正确的位置继续执行，在切换之前，会保存上一个任务的状态。

- 对于linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2和3步是进程和线程切换都要做的。所以明显是进程切换代价大,并且伴有大量的内核的执行相应的进程调度算法

- 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

- 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。



# 任务调度的开销

1. CPU执行任务调度的开销，主要事是进程上下文切换的开销，

2. 任务调度后，CPU Cache /TLB 不命中，导致缺页中断的开销
 
无论是进程还是线程，都具备上下文切换的开销的，主要的点在于第二点，线程切换是不涉及到第二点的，而
 
对于第1点的开销，不管是进程调度还是线程调度都是必须的，所以，两者的差异体现在第2点。


[线程调度为什么比进程调度更少开销？](https://www.cnblogs.com/gmpy/p/10265284.html)


# 背景知识

进程页表：每个进程自己的页表，放在进程自身的页目录task_struct.pgd中。
在保护模式下，从硬件角度看，其运行的基本对象为“进程”(或线程)，

而寻址则依赖于“进程页表”，**在进程调度而进行上下文切换时，会进行页表的切换**



**TLB**

TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本,进程切换代表这个东西全部失效


# 进程通信和线程通信的区别

**前提知识**

1. 线程是没有独立地址空间的，共享数据和代码段等， 

2. 进程是有独立的地址空间的，

所有统一进程内的线程同属于一个地址空间，是可以直接通信的，所以只要考虑共享数据的互斥问题


>只有进程间需要通信,同一进程的线程share地址空间,没有通信的必要，但要做好同步/互斥mutex,保护共享的全局变量。线程拥有自己的栈。

**区别**

1. 线程间通信：由于多线程共享地址空间和数据空间，所以多个线程间的通信是一个线程的数据可以直接提供给其他线程使用，而不必通过操作系统（也就是内核的调度）。
>线程间的通信目的主要是用于线程同步，锁机制：包括互斥锁、条件变量、读写锁、信号量机制、信号机制、事件机制

2. 进程间的通信则不同，它的数据空间的独立性决定了它的通信相对比较复杂，需要通过操作系统。

进程通信的有两种方式需要明白

1. 信号量，信号量是一个计数器，可以用来控制多个进程对共享资源的访问
2. 信号，是不一样的东西，信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

**区别实质**

需不需要操作系统内核的介入

# 守护进程

守护进程就是独立于终端而存在的一种进程，终端关闭了，但是她还是在背后运行，提供服务，除非主机关闭

守护进程:独立于终端而存在的进程，不会因为终端结束而结束，一直伴随系统进程而存在，类似inetd网络进程122

inetd 是监视一些网络请求的守护进程

**redis守护进程**

daemonize是用来指定redis是否要用守护线程的方式启动。

守护进程是⼀一种很有用的进程。Linux的大多数服务器就是用守护进程实现的。比如，Internet服务器inetd，Web服务器httpd等。同时，守护进程完成许多系统任务


**如何创建守护进程**

web服务器httpd

**创建过程**

守护进程的父进程是init进程

**守护进程的创建步骤**

1. fork()创建子进程，父进程exit()退出

这是创建守护进程的第一步，由于守护进程是脱离控制终端存在的，因此

2. 在子进程中调用 setsid()函数创建新的会话

[守护进程(daemon)详解与创建](https://blog.csdn.net/woxiaohahaa/article/details/53487602)

# 参考链接

[线程上下文切换与进程上下文切换](https://blog.csdn.net/bxw1992/article/details/78115860)

[TLB的作用及工作原理](https://www.cnblogs.com/alantu2018/p/9000777.html)

