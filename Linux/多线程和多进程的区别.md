# 主要从几个点来回答
1. 作用，进程是资源分配的单位，进程具有独立的地址空间，而线程是没有的；线程是系统进行调度的基本单位
2. 上下文切换的开销，进程要远远大于线程
3. 线程通信代价低，进程通信代价高
4. 线程没有独立的地址空间，进程有独立的地址空间
5. 从属关系，一个进程可以有多个线程，至少有一个


- 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。
- 资源分配给进程，同一进程的所有线程共享该进程的所有资源。
- CPU分给线程，即真正在CPU上运行的是线程。

## 上下文切换
上下文切换只能发生在内核态中。
### 进程切换
1. 进程上下文包含了进程执行所需要的所有信息
    - **用户地址空间**：程序代码段，数据，用户堆栈
    - **控制信息**：进程描述符，内核栈
    - **硬件上下文**：CU
    
**关于内核栈这里面要联系下内核态和用户态**

> 每个进程在创建的时候都有一个进程stack和内核stack，

2. 进程切换分为三步

- 切换页目录以使用新的地址空间，切换不同进程的地址空间
- 切换内核stack，由用户进程stack转化为内核stack，由用户态进出入内核态
- 切换硬件上下文，一些程序执行的环境


**什么叫做硬件上下文**

>尽管每个进程可以拥有属于自己的地址空间，但是所有进程必须共享CPU寄存器，因此，在恢复一个进程的执行前，内核必须确保每个寄存器装入了挂起进程时的值
进程恢复执行前必须装入寄存器的那一组数据成为硬件上下文。进程切换可以这样表述：保存将要切换出的进程的硬件上下文，用将要切换进来的进程的硬件上下文来代替。linux2.6使用软件进行进程切换。进程切换只发生在内核态




### 线程切换

上下文切换的定义
> 上下文切换就是从当前执行任务切换到另一个任务执行的过程。但是，为了确保下次能从正确的位置继续执行，在切换之前，会保存上一个任务的状态。

- 对于linux来说，线程和进程的最大区别就在于地址空间。对于线程切换，第1步是不需要做的，第2和3步是进程和线程切换都要做的。所以明显是进程切换代价大,并且伴有大量的内核的执行相应的进程调度算法

- 线程上下文切换和进程上下文切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。

- 另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。


# 背景知识

进程页表：每个进程自己的页表，放在进程自身的页目录task_struct.pgd中。
在保护模式下，从硬件角度看，其运行的基本对象为“进程”(或线程)，

而寻址则依赖于“进程页表”，**在进程调度而进行上下文切换时，会进行页表的切换**



**TLB**

TLB就是页表的Cache，其中存储了当前最可能被访问到的页表项，其内容是部分页表项的一个副本,进程切换代表这个东西全部失效


# 参考链接

[线程上下文切换与进程上下文切换](https://blog.csdn.net/bxw1992/article/details/78115860)

[TLB的作用及工作原理](https://www.cnblogs.com/alantu2018/p/9000777.html)

