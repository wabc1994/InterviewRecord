堆和栈是两种内存分配的两个统称。可能有很多种不同的实现方式，但是实现要符合几个基本的概念:

1. 对栈而言，栈中的新加数据项放在其他数据的顶部，移除时也只能移除最顶部的数据（不能越位获取）。
2. 对堆而言，数据项位置没有固定的顺序。你可以以任何顺序插入和删除，因为他们没有“顶部”数据这一概念。

# 栈

**栈是为执行线程留出的内存空间**。当函数被调用的时候，栈顶为局部变量和函数参数，返回值等。当函数执行完毕，块就没有用了，可能在下次的函数调用的时候再被使用。栈通常用后进先出（LIFO）的方式预留空间；因此最近的保留块（reserved block）通常最先被释放。这么做可以使跟踪堆栈变的简单；从栈中释放块（free block）只不过是指针的偏移而已。

1.	栈要受到内存块的限制，不断的函数嵌套/为局部变量分配太多的空间，可能会导致栈溢出。当栈中的内存区域都已经被使用完之后继续向下写（低地址），会触发一个 CPU 异常。这个异常接下会通过语言的运行时转成各种类型的栈溢出异常。
2. 如果在编译之前精确知道需要分配数据的大小，并且数据不是太大的时候，可以使用栈。
3. 在栈上的数据可以直接访问（不是非要使用指针访问）。
4.	栈经常与 sp 寄存器（译者注：“stack pointer”，了解汇编的朋友应该都知道）一起工作，最初 sp 指向栈顶（栈的高地址）。
5.	CPU 用 push 指令来将数据压栈，用 pop 指令来弹栈。当用 push 压栈时，sp 值减少（向低地址扩展）。当用 pop 弹栈时，sp 值增大。存储和获取数据都是 CPU 寄存器的值。
6.	当进入函数时，sp 向下扩展，扩展到确保为函数的局部变量留足够大小的空间。如果函数中有一个 32-bit 的局部变量会在栈中留够四字节的空间。当函数返回时，sp 通过返回原来的位置来释放空间。
7.	如果函数有参数的话，在函数调用之前，会将参数压栈。函数中的代码通过 sp 的当前位置来定位参数并访问它们。
8.	函数嵌套调用和使用魔法一样，每一次新调用的函数都会分配函数参数，返回值地址、局部变量空间、嵌套调用的活动记录都要被压入栈中。函数返回时，按照正确方式的撤销。

可以结合下图理解：

![][2]

# 堆

**堆（heap）是为动态分配预留的内存空间**。和栈不一样，从堆上分配和重新分配块没有固定模式；你可以在任何时候分配和释放它。这样使得跟踪哪部分堆已经被分配和被释放变的异常复杂；有许多定制的堆分配策略用来为不同的使用模式下调整堆的性能。

1.	堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内存块中找到一些满足要求的合适块。这个操作会更新堆中的块链表。这些元信息也存储在堆上，经常在每个块的头部一个很小区域。
2.	堆增加新块时通常从地地址向高地址扩展。因此你可以认为堆随着内存分配而不断的增加大小。如果申请的内存大小很小的话，通常从底层操作系统中得到比申请大小要多的内存。
3.	申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。进而申请大块内存失败，虽然空闲块的总和足够，但是空闲的小块是零散的，不能满足申请的大小，这叫做`堆碎片`。
4.	当旁边有空闲块的已用块被释放时，新的空闲块可能会与相邻的空闲块合并为一个大的空闲块，这样可以有效的减少堆碎片的产生。
5.	在堆上的变量必须要手动释放，不存在作用域的问题。数据可用 delete, delete[] 或者 free 来释放，如果忘记释放，可能造成内存泄漏。
6.	在 C++ 中，在堆上创建的数据需要使用指针访问。
7.	如果申请的堆缓冲区过大的话，可能申请失败。
8.	在运行期间不知道会需要多大的数据或者需要分配大量的内存的时候，建议使用堆。

可以结合下图理解：

![][1]

# 栈与堆

每一个线程都有一个栈，但是每一个应用程序通常都只有一个堆（尽管为不同类型分配内存使用多个堆的情况也是有的）。

1. 当线程创建的时候，操作系统（OS）为每一个系统级（system-level）的线程分配栈。通常情况下，操作系统通过调用语言的运行时（runtime）去为应用程序分配堆。 
2. 栈附属于线程，因此当线程结束时栈被回收。堆通常通过运行时在应用程序启动时被分配，当应用程序（进程）退出时被回收。在多线程环境下每一个线程都可以有他自己完全的独立的栈，但是他们共享堆。
3. 当线程被创建的时候，设置栈的大小。在应用程序启动的时候，设置堆的大小，但是可以在需要的时候可以扩展（分配器向操作系统申请更多的内存）。 
4. 栈比堆要快，因为它存取模式使它可以轻松的分配和重新分配内存（指针/整型只是进行简单的递增或者递减运算），然而堆在分配和释放的时候有更多的复杂的 bookkeeping 参与。另外，在栈上的每个字节频繁的被复用也就意味着它可能映射到处理器缓存中，所以很快。

看一个简单的例子：

    int foo()
    {
        char *pBuffer; //<--nothing allocated yet (excluding the pointer itself, which is allocated here on the stack).
        bool b = true; // Allocated on the stack.
        if(b)
        {
            //Create 500 bytes on the stack
            char buffer[500];
    
            //Create 500 bytes on the heap
            pBuffer = new char[500];
    
        }//<-- buffer is deallocated here, pBuffer is not
    }//<--- oops there's a memory leak, I should have called delete[] pBuffer;

堆区，栈区的区别：

* 管理方式：对于栈来讲，是由编译器自动管理；对于堆来说，分配释放工作由程序员控制，容易造成内存泄露。
* 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的。
* 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。
* 生长方向：对于堆来讲，向着内存地址增加的方向增长；对于栈来讲，向着内存地址减小的方向增长。
* 分配方式：堆都是动态分配（运行期）的，没有静态分配（编译期）的堆。栈有2种分配方式：静态分配和动态分配（alloca()函数可以动态分配栈的内存空间，释放的时候由编译器自己释放）。
* 分配效率：计算机在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，效率比栈要低得多。

# 更多阅读

[Linux内存管理](http://www.kerneltravel.net/journal/v/mem.htm)  
[什么是堆和栈，它们在哪儿？](http://blog.jobbole.com/75321)  
[What and where are the stack and heap?](http://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap)  
[Understanding the Stack](https://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html)  


[1]: http://7xrlu9.com1.z0.glb.clouddn.com/Linux_OS_StackHeap_1.png
[2]: http://7xrlu9.com1.z0.glb.clouddn.com/Linux_OS_StackHeap_2.png

