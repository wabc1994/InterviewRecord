逻辑地址经段机制转化成线性地址；线性地址又经过页机制转化为物理地址
但是我们要知道Linux系统虽然保留了段机制，但是将所有程序的段地址都定死为0-4G，所以虽然逻辑地址和线性地址是两种不同的地址空间，但在Linux中逻辑地址就等于线性地址，它们的值是一样的）
# 进程地址空间
程序的内存映像从低地址到高地址依次是： 
- txt段 
- data段: 已初始化的全局变量和已初始化的static变量； 
- bss段: 未初始化的全局变量和未初始化的static变量以及初始化为零的全局变量和静态变量（参考这里和这里）（未初始化的全局变量和static变量，系统自动赋值为零。这个段在编译成 .exe可执行文件时，只是标记了一下这个段的大小，并没有实际的分配全为零的页框。 
　　例如：一个程序的txt段的大小是8kB，初始化数据段的大小是8kB，未初始化的数据段（BSS）的大小是4kB，那么可执行文件的大小是 16kB（代码+初始化的数据）加上一个很短的头部来告诉系统在初始化的数据后再另外分配4KB，同时在程序启动之后把他们初始化零为0。这个技巧巧妙的避免了在可执行文件中中存储4kB的0. 
　　更进一步，为了避免分配一个全是0的物理页框，在初始化的时候，linux就分配了一个静态零页面，即一个全为零的写保护页面。当加载程序的时候，未初始化的数据区域被设置为指向该零页面。当一个进程真正要写这个区域的时候，写时复制机制就开始起作用，一个实际的页框就被分配给该进程。——《现代操作系统P428》 
- 堆: 通常情况下堆也是请求二进制零的页面**　，往上生长——《深入理解计算机系统P585, P587》 
- 栈: 通常情况下往下生长

# 几种地址空间段理解
## 逻辑地址  
可以认为是cpu执行程序过程中的一种中间地址。
## 线性地址
线性地址，也即虚拟地址，如果逻辑地址对应的是硬件平台段式管理转换前的地址的话，那么线性地址则对应了硬件页式内存的转换前的地址
## 虚拟内存
跟线性地址是同一个东西
## 物理地址
用于内存芯片级的单元寻址，与地址总线相对应。这个概念应该是这几个概念中最好理解的一个，但是值得一提的是，虽然可以直接把物理地址理解成插在机器上那根内存本身
上述关系几个概念总体关系

Linux操作系统采用**虚拟内存管理技术**，使得每个进程都有各自互不干涉的进程地址空间。该空间是块大小为4G的线性虚拟空间，用户所看到和接触到的都是该虚拟地址
1. 无法看到实际的物理内存地址。利用这种虚拟地址不但能起到保护操作系统的效果（用户不能直接访问物理内存）
2. 而且更重要的是，用户程序可使用比实际物理内存更大的地址空间
## 从虚拟地址到物理地址
从上面已经看到进程所能直接操作的地址都为虚拟地址。当进程需要内存时，从内核获得的仅仅是虚拟的内存区域，而不是实际的物理地址，进程并没有获得物理内存（物理页面——页的概念请大家参考硬件基础一章），获得的仅仅是对一个新的线性地址区间的使用权。实际的物理内存只有当进程真的去访问新获取的虚拟地址时，才会由“请求页机制”产生“缺页”异常，从而进入分配实际页面的例程。

# 物理内存管理（页管理）
1. Linux内核管理物理内存是通过分页机制实现的，它将整个内存划分成无数个4k（在i386体系结构中）大小的页，从而分配和回收内存的基本单位便是内存页了 
利用分页管理有助于灵活分配内存地址，因为分配时不必要求必须有大块的连续内存，系统可以东一页、西一页的凑出所需要的内存供进程使用。
2. 虽然如此，但是实际上系统使用内存时还是倾向于分配连续的内存块，因为分配连续内存时，页表不需要更改，因此能降低TLB的刷新率（频繁刷新会在很大程度上降低访问速度）。
## 段式内存管理
## 页式内存管理
## 伙伴关系
为了便于页面的维护，将多个页面组成内存块，每个内存块都有 2 的方幂个页，方幂的指数被称为阶 order。order相同的内存块被组织到一个空闲链表中。伙伴系统基于2的方幂来申请释放内存页。
# 内核内存使用
## Slab
## Kmalloc
## 内核非连续内存分配（Vmalloc）