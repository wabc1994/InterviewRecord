# 地位
CLH锁是实现AQS锁的基础，AQS又是juc中的内置同步器（ReentrantLock、CountDownLatch、Semaphore、CyclicBarrier）的基础。
CLH锁的行为---实现Lock锁
>CLH lock queue其实就是一个FIFO的队列，队列中的每个结点（线程）只要等待其前继释放锁就可以了。
# 关键点
CLH锁如何优化同步带来的花销，其核心思想是：通过一定手段将所有线程对某一共享变量轮询竞争转化为一个线程队列且队列中的线程各自轮询自己的本地变量。
# 如何构建队列？
FIFO队列(队列中保存的就是一个线程方式的方式)
为了保证公平性，构建的将是一个FIFO队列，构建的时候主要通过移动尾部节点tail实现队列的排队，每个想获取锁的线程创建一个新节点并通过CAS原子操作将新节点赋予tail，然后让当前线程轮询前一节点的某个状态位，
众多线程长时间对某资源的竞争，通过有序化这些线程转化为只需对本地变量检测。唯一存在竞争的地方就是在入队列之前对尾节点tail的竞争，但竞争的线程的数量已经少了很多，且比起所有线程直接对某资源竞争的轮询次数也减少了很多，节省了很多CPU缓存同步操作，大大提升系统性能，利用空间换取性能。
(其实上述做法也类似与zookeeper中的分布锁，当前节点序号与前面一个序号进行比较)
## 包含的数据结构
>内部类Node：Node节点代理一个竞争者，它有一个标记自己是否处于竞争或锁定状态的标志，true：正在竞争或已经获得锁；false：已经释放锁
 成员变量：ThreadLocal<Node> current;——每个线程调用current.get()将获得自己参与竞争的代理，即一个Node实例
 成员变量：ThreadLocal<Node> pre;——每个线程调用pre.get()将获得上一个竞争者
 成员变量：AtomicReference<Node> tail;——维持在锁内部的最后一个竞争者节点
 