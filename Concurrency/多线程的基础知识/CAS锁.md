

[其他并发知识lock, vodatile， synchronizd并发的链接](https://github.com/wabc1994/Leetcode2/blob/master/Java%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/lock%E5%92%8Csynchronized%E7%9A%84%E5%8C%BA%E5%88%AB.md)

# 背景：锁的代价？
锁是用来做并发最简单的方式，当然其代价也是最高的。
1. 内核态的锁的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，
2. 等待锁的线程会被挂起直至锁释放。
3. 在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。操作系统对多线程的锁进行判断就像两姐妹在为一个玩具在争吵，然后操作系统就是能决定他们谁能拿到玩具的父母， 这是很慢的。（操作系统需要作出判断，所以很慢该这种情况）


# 在无锁的情况下如何实现高并发？
 - 在加锁的情况下进行优化锁 ConcurrentHashMap()
 - 采用无锁的情况下实现非阻塞算法情况（多种算法来实现）

# CAS(比较与交换、Compare and Swap)

# 基本概念 

CAS是一种有名的无锁算法，是一项乐观锁算法(操作前假设共享数据没有经过修改)，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其他的线程并不会被挂起，而是被告知这次失败了，并可以再次尝试。

## 操作的数据

CAS有三个操作数， 内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V 修改为B， 否则什么都不做。 

> 就是指比较V和A，如果相等，证明共享数据没有被修改，可以替换成新值B，然后继续往下执行情况； 如果不相等，说明共享数据已经被修改，放弃已经所做的操作。

## CAS算法的优势

CAS（比较并交换）是CPU指令级的操作，只有一步原子操作，所以非常快。而且CAS避免了请求操作系统来裁定锁的问题，不用麻烦操作系统，直接在CPU内部就搞定了

** 我们平常都说CAS锁，乐观锁，严格来说并不是锁来的，而是一种**

## Java中的CAS锁机制
JVM中的CAS操作是利用了处理器cpu提供的CMPXCHG指令实现的。


