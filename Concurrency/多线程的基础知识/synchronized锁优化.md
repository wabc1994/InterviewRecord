# JDK1.6 synchronized的优化

JVM对于同步锁的处理从偏向锁开始，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，然后到自旋锁，最终升级到重量级锁，
  
**自旋锁，偏向锁，轻量级锁都是乐观锁的思想**

**重量级锁是悲观锁的思想**  
   
   
**锁的变化过程**

要明白在整个锁的变化过程当中，锁还是那个对象监视器，都是那个，只不过是对象头里面存储的内容标志位发生了变化，然后这种变化反映在

对前来抢锁的线程身上而已，就是对抢锁线程的惩罚度不一样而已

比如如果是重量级锁，那么前来强锁的线程如果失败了， 那么就直接进入睡眠阻塞状态，如果是自旋的，那么该锁就是一个自旋的状态

抢锁都是尝试通过CAS操作改变那个state的

## 自旋锁

## 锁粗化

锁粗化主要出现在两种情况下
1. 如果一系列的连续操作都对同一个对象反复加锁和解锁，
2. 


通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样，等待在这个锁上的其他线程才能尽早的获得资源执行任务。

但是，凡事都有一个度，如果对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统宝贵的资源，反而不利于性能的优化 。

举个例子：


```java
public void demoMethod(){  
        synchronized(lock){   
            //do sth.  
        }  
        //...做其他不需要的同步的工作，但能很快执行完毕  
        synchronized(lock){   
            //do sth.  
        } 
    }
```


这种情况，根据锁粗化的思想，应该合并：
```
public void demoMethod(){  
        //整合成一次锁请求 
        synchronized(lock){   
            //do sth.   
            //...做其他不需要的同步的工作，但能很快执行完毕  
        }
    }
    
```

在循环体当中使用锁

```java
for(int i = 0; i < CIRCLE; i++){  
            synchronized(lock){  
                 //...
            } 
        }
```

升级为

```java
synchronized(lock){ 
            for(int i=0;i<CIRCLE;i++){ 

            } 
        }
```

## 偏向锁


偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。 

**相当于无锁操作**

## 轻量级锁



## 重量级锁
重量级锁就是直接导致争用不到锁的线程进入阻塞状态，类似于Java jdk1.5之前的synchronized


## 锁消除

锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。