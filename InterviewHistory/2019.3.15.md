# 2019.3.15

网易的面试主要分为三个部分
1. 项目
2. 数据库
3. 网络
4. 操作系统

## 1. 数据库

参考链接

By default, innodb_file_per_table is disabled.

[Why does InnoDB store all databases in one file?](https://dba.stackexchange.com/questions/15531/why-does-innodb-store-all-databases-in-one-file)

1. 数据库的表是如何在磁盘中存储的？
表在磁盘当中的存储根据不同的存储引擎是不一样的。

无论是mysql还是innodb表的结构定义等东西都是存储在.frm的扩展文件当中




数据库表的存储主要有关的文件主要有下面几个

1. frm: 描述表结构文件，字段长度等
2. MYD: 数据信息文件，存储数据信息
3. MYI: 索引信息文件
4. 独立表存储模式：每个表都有一个.ibd文件(存储数据信息和索引信息)，如果采用共享表空间形式： 所有表的数据信息


![](https://github.com/wabc1994/InterviewRecord/blob/master/InterviewHistory/pic/storetable.png)

## innodb如何存储表
MySQL 使用Innodb 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在.frm文件,


要存储的数据

1. Table Data Pages

2. Table Index Pages

3. Table MetaData 

4. MVCC data (为了支持事务和ACID四个特性) 

### Innodb的两种表空间
1. 独立表空间， 当开启每个表一个文件时，innodb_file-per-table,每个innodb表和他的索引都在一个单独的.idb文件，在5.6.6之后就可以支持了，在配置文件my.cnf
2. 系统表空间 **(也叫共享表空间)**，InnoDB表会创建在系统表空间中，所有的数据和索引存放到一个文件, 所有表的数据和索引都存储在ibdata1文件当中


### 共享表空间

**优点**

- 可以将表空间分成多个小文件放在各个磁盘(表空间文件大小不受大小的限制，如一个表可以分布在不同的文件上面)

### 独立表空间

**优点**
1. 每个表都有自已独立的表空间。
2. 每个表的数据和索引都会存在自已的表空间中。
3. 可以实现单表在不同的数据库中移动。

**缺点**
4. 单表增加过大，



[INNODB共享表空间与独占表空间](https://blog.51cto.com/l0vesql/1894887)
[innodb共享表空间和独立表空间 ](https://blog.csdn.net/wilsonke/article/details/48376561)

10. leveldb和rockdb等数据库的存储结构是怎样的？



11. 数据库的索引

### 索引
12. 数据库的存储引擎
>异同点，全文索引这个点没有回答出来，还有比如崩溃恢复，提交，回滚等，支持ACID等特性也是要说出来的，


1. MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；
2. MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引，只要是在text,char,varchar这类字段当中使用，适用的场景是模糊查询


9.  redis 的持久化机制， 各有什么优缺点？该怎么选择


13. 数据库的锁机制
15. where 查询一个东西是否使用了索引


## 如何进行程序调试代码

**问题**

3. 如果程序crash了，多余的日志在哪里可以查找？程序崩溃了还可以查找到日志信息吗
4. 

### core-dump
**定义**

核心转储

Linux平台下的core- dump 文件，开启生成该文件的话，Linux系统会在程序运行异常的时候而又没有日志信息(进程内部又没有捕获的情况下)对内存做一个快照，把进程奔溃的此刻内存、运行堆栈，cpu寄存器状态的保存在一个文件当中。

**开启**

ulimit -c 如果为0的话就是没有开启， 

开启，并且设置该文件为无效大的情况

ulimit -c unlimited,则任何情况都会产生core-dump文件


**自定义core文件**

>可以进行一些基本的配置信息

>1. 程序名称，coredump时间，进程ID等信息


**查看core-dump文件当中的堆stack**

gdb filename core

> filename是可执行文件， core是生成的核心转储文件
core是程序非法执行后core dump后产生的文件
>bt 或者where命令


### 参考链接

[linux下core dump](https://www.cnblogs.com/Anker/p/6079580.html)

4. Ddos 攻击有哪些以及应对方案


# 着重介绍go
5. 协程了解吗

   主要从调度开销，线程stack， 以及如何实现一个用户应用程序级别的调度器，以及用户线程与操作系统级别内核调度实体线程的映射关系， 

## fork()
6. fork背后的原理是什么？
>先从fork()返回值，然后说到vfork 再到写时复制，然后不管是fork(),，底层是通过新建一个进程控制块task_struct，然后将原来的进程的地址空间里面内容复制到新的进程控制块里面，vfork() 还是clone() 到系统调用sys\_fork(),sys\_vfork(), 然后再到do\_fork来实现，do\_fork里面有一个copy\_process()完成进程块PCB的复制，


7. 给一个代码输出什么？(fork(),听得不是很清楚)

7. tcp有哪些重传机制

8. 滑动窗口机制


10. 日志信息是存储在内存还是哪里，采用什么数据结构存储


16. https是如何进行通信如果进行通信，会对url 进行一个加密吗
>是的，HTTPS对URL加密了。SSL连接建立在TCP层和HTTP层之间。客户端和服务器首先建立一个安全的加密的TCP连接(通过SSL/TLS协议)，然后客户端将通过该加密的TCP连接发送HTTP请求(GET，POST，DELETE ...)。 https“URLs”确实是加密的。整个请求和响应都是加密的，包括URL。 


17. https是每次都要建立连接重新建立连接吗
18. Linux当中的写入磁盘是怎样的
19. 分段和分页
>面向程序员，面向系统(解决内存碎片问题)
>1. 页是信息的物理单位，分页是为了实现离散分配方式，以消减内存的外零头，提高内存的利用率。分页仅仅是由于系统管理的需要而不是用户的需要
>2.  段是信息的逻辑单位，分段的目的是为了能更好地满足用户的需要
>3.页的大小固定，由系统把逻辑地址划分为页号和页内地址两部分，段的长度却不固定，决定于用户所编写的程序
>4. 分页的作业地址空间是一维的，即单一的线性地址空间。 分段的作业地址空间是二维的 在标识一个地址时，即需给出段名，又需给出段内地址

## 网络

### 1. ping的原理


### 2. NAT协议
当内部网络访问外部网络时，地址转换将会选择一个合适的外部地址，来替代内部网络数据报文的源地址。

NAT主要用于实现私有网络访问公共网络的功能。这种通过使用少量的公网IP地址代表较多的私网IP地址的方式，将有助于减缓可用IP地址空间的枯竭。

**内部网络很多主机个ip地址共用一个公用IP地址**

私网IP地址是指内部网络或主机的IP地址，公网IP地址是指在因特网上全球唯一的IP地址。


**主要有两个作用**

1. **NAT的主要作用，是解决IP地址数量紧缺。当大量的内部主机只能使用少量的合法的外部地址，就可以使用NAT把内部地址转化成外部地址。**

2. **NAT还可以防止外部主机攻击内部主机（或服务器）。**

关键的问题如何利用地址映射？
>如何将大量的内部地址，映射成少量的外部地址


### tcp长连接时如何实现的？

为何需要心跳机制？
>由于网络复杂的环境，可能一条长连接已经被断开了主要是为了及时关闭已经被关闭的连接，但是客户端又不能够及时收到该条连接已经被关闭的信息，

setsockopt(keepalive参数)，

```java
 int flags =1;
 if (setsockopt(sfd, SOL_SOCKET, SO_KEEPALIVE, (void *)&flags, sizeof(flags))) 
 { 
    perror("ERROR: setsocketopt(), SO_KEEPALIVE");         exit(0); 
 };
 ```
 
**引申问题： TCP如何保持长连接,并识别不同请求的?**
 
 1. keepalive
 2. TCB: Transmission Control Block 来唯一识别一个TCP连接
 
 3. 局部性原理：局部性原理是指CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。**LRU就是利用了时间局部性原理**。时间局部性原理
：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。



## 算法题
1. two sum
2. three sum
3. 两个队列模拟一个stack


## 总结

还是要调理清晰点，很多东西都没表达完，还是有点问题