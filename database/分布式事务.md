# 什么是分布式事务？

## 概念

之前所所学的数据库系统与设计中的内容都是基于单数据库的本地事物，比如数据库中的事务，并发操作， 隔离级别等情况都是单库事务，并不支持跨库事务。而随着微服务等架构的普及，一个大型业务系统往往由**若干个子系统**组成，这些子系统都有自己独立数据库。往往一个业务流程需要多个子系统共同完成，而这些操作需要在一个事务中完成。在微服务系统中，这些业务场景是普遍存在的。此时，我们就需要在数据库之上通过某种手段，实现支持跨数据库的事务支持，这也就是大家常说的“分布式事务”。

## 案列

这里举一个分布式事务的典型例子——用户下单过程。 当我们的系统采用了微服务架构后，一个电商系统往往被拆分成如下几个子系统：商品系统、订单系统、支付系统、积分系统等。整个下单的过程如下：

1. 用户通过商品系统浏览商品，他看中了某一项商品，便点击下单
2. 此时订单系统会生成一条订单
3. 订单创建成功后，支付系统提供支付功能
4. 当支付完成后，由积分系统为该用户增加积分

上述步骤2、3、4需要在一个事务中完成。对于传统单体应用而言，实现事务非常简单，只需将这三个步骤放在一个方法A中，再用Spring的@Transactional注解标识该方法即可。Spring通过数据库的事务支持，保证这些步骤要么全都执行完成，要么全都不执行。但在这个微服务架构中，这三个步骤涉及三个系统，涉及三个数据库，此时我们必须在数据库和应用系统之间，通过某项黑科技，实现分布式事务的支持。

# 如何解决分布式事务的一致性问题

## - CAP理论

## - BASE理论

- bsically available 代表基本可用，

- soft state 软状态，软一致性，不要求实时立刻的那种一致性状态

- Eventually consistently 最终一致性， 最终客户端访问各个分布式节点数据副本都可以

## - 分布式事务协议


# 分布式事务的协议

分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。

为了实现上述的目标就有了下面几个理论

# 分布式事务的解决方案
1.  XA 方案,B 包括两阶段和三阶段协议， 存在的问题就是数据的一致性问题

2. TCC try confirm commit 三个步骤的方案情况，主要是依靠应用层来解决，通过代码层来人为实现，
强隔离性、严格一致性、实时性高，适用于对业务要求比较高的场景，比如处理账户、收

3. 本地消息队列情况，引入消息队列来解决消息同步的问题，就是日志同步到各个节点的问题情况


4. 可靠消息最终一致性方案

5. 最大努力通知方案


[分布式事务的几种解决方案](https://github.com/wabc1994/advanced-java/blob/master/docs/distributed-system/distributed-transaction.md)

## 两阶段提交协议2pc


主要的缺点

1. 同步阻塞
2. 单点问题
3. 数据不一致性

就是强一致性

## 三阶段提交协议3pc
 
 针对2PC方案存在的问题，我们进行了一定程度的改进

1. 增加一个超时机制， 解决了阻塞问题
2. 两阶段直接增加一个插入准备阶段，解决了数据不一致性问题


## paxos协议

---
上面是理论部分情况， 然后主要是是in action zookeeper 部分情况

# zookeeper 

[参考链接](https://github.com/wabc1994/Leetcode2/tree/master/zookeeper)

上面三个协议如何做，具体去查看 《从paxos 到zookeeper》这本书即可，具体如何实现的情况 

