# 多版本并发控制MVCC

多版本控制是一个乐观锁，在不同的存储引擎当中具有不同的实现方式， 面试过程当中我们主要是关注innodb当中的实现？
 

**表锁在服务器层实现, 行锁在存储引擎层实现**

**MySQL 会在两个层面做并发控制: 服务器层和存储引擎层**

![](https://github.com/wabc1994/InterviewRecord/blob/master/database/pic/lockInDatabase.png)


# 乐观锁和悲观锁





## 乐观锁实现

**有了数据库锁了我们为何还需要乐观锁**
> 在数据库锁中，在表锁中我们读写是阻塞的，基于提升并发性能的考虑，MVCC一般读写是不阻塞的(所以说MVCC很多情况下避免了加锁的操作)

乐观锁：利用程序处理并发。方式大概有下面几种
1. 对记录加版本号
2. 对记录加时间戳

## 悲观锁 
悲观锁一般就是我们通常说的数据库锁机制，下面讨论的都是基于悲观锁，比如表锁，行锁，页锁


在MyISAM中只用到表锁，不会有死锁的问题(MyIsam不支持事务。)，锁的开销也很小，但是相应的并发能力很差(高版本的MySQL基本放弃MyISAM)。innodb实现了行级锁和表锁，锁的粒度变小了，并发能力变强，但是相应的锁的开销变大，很有可能出现死锁。同时inodb需要协调这两种锁，算法也变得复杂。InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

表锁和行锁都分为共享锁和排他锁（独占锁），而更新锁是为了解决行锁升级（共享锁升级为独占锁）的死锁问题。

innodb中表锁和行锁一起用，所以为了提高效率才会有意向锁（意向共享锁和意向排他锁）


## InnoDB行锁的细分
多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题

innodb 的行锁是在有索引的情况下，没有索引的表是锁定全表的

1. 共享锁
2. 排他锁
3. 更新锁


**InnoDB什么情况下使用表锁什么情况使用行锁**

InnoDB行锁是通过给索引上的索引项加锁来实现的，只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。
## 意向锁
为了解决表锁和行锁之间存在的问题而映射出来的意向锁,意向锁的本质是为行锁和表锁的共存问题

要申请行锁的事务，数据库自动为我们申请一个意向锁，有了意向锁，就代表了该表有了行锁的存在或者即将偶行级锁的存在，

[意向锁存在的意义](https://www.zhihu.com/question/51513268)

![](https://github.com/wabc1994/InterviewRecord/blob/master/database/pic/%E6%84%8F%E5%90%91%E9%94%81.jpeg)

将锁冲突检测的时间复杂度由O(N)降低为O(1), 有了意向锁，就跟宣誓了自己的领地一样，这个表已经有一个行锁了， 就可以直接阻塞其他尝试获得排他锁的表锁

>Intention locks reduce the number of locks that must be examined when a new lock is allocated. Intention locks allow transactions to quickly determine if rows (or pages) in a given table have been locked by other transactions.

**我自己对意向锁的理解？**

为了减少数据库监测冲突的次数，减少时间复杂度，减少行遍历的次数

# 背景 

**这个问题也可以这么问？**

> 既然有了行锁和表锁了，为何要需要更进一步的实现多版本控制

- 大多数的MYSQL事务型存储引擎，比如InnoDB,都不使用一种简单的行锁机制.事实上,他们都和MVCC–多版本并发控制来一起使用.

- 大家都应该知道,锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销.
 

innodb 当中的并发控制机制，行锁在一定程度开销比较大，大多数的存储引擎都不适用一种简单的行锁机制。

>innodb 有两种锁机制，一种是行锁，另一种是表锁，这两种锁可以认为是悲观锁来的， 而innodb当中的mvcc 其实是另一种锁思想，乐观锁的实现，乐观锁的实现一般由版本号和时间戳，在更新的同时更新版本号和时间戳。
从用户的角度来看，好像是数据库可以提供同一数据的多个版本。


**什么时候使用mvcc, 什么情况下使用？**

>能不用行锁，能使用mvcc 版本控制可以减少锁的使用，降低系统的开销



# 为何要比较版本号
因为并发的实质是多个事务并发执行，操作同一个数据库表，同一个表当中不同行通过不同的创建时间和删除时间，就可以跟是哪个事务操作他的隔离开来， 先操作的事务，或后面再操作的事务情况

## SELECT比较版本号

select根据下面两个条件来检索每行记录：

- 当前事务号
- 行的创建时间和删除时间
1. innoDB 只会选择那些行的创建时间早于或者等于当前事务号的数据行。这样可以保证确保读取的行，要么是在事务开始之前就已经存在，要么是事务本次插入或者修改过的
2. 行的删除版本要么是未定义的， 要么大于当前事务版本号，这可以确保事务读取到的行，在事务开始之前未被删除(未被定义就是未被删除)**(是后面的事务导致的删除)**

只有满足1，2同时满足的记录，才能返回作为查询的结果


## DELETE

InnoDB会为删除的每一行保存当前系统的版本号(事务的ID)作为删除标识. 


## UPDATE
是直接在表当中生成生成新的一行，

## INSERT

直接在表当中插入新的一行

##

# 如何理解MVCC
其实mvcc 我们也可以使用 CAS机制来理解的？
也是一种不加锁的， 比如比较当前事务的版本号和创建时间版本号和删除版本号这两个东西，判断我们是否要进行update、select、insert、delete等的行为情况
特别是在查询的时候select操作， select操作的情况


# 参考链接

[数据库的锁机制及原理 ](https://blog.csdn.net/C_J33/article/details/79487941)

[MYSQL MVCC 实现机制 ](https://blog.csdn.net/whoamiyang/article/details/51901888)


