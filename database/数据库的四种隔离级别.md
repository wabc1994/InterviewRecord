# 数据库的四种隔离几杯

数据库一共有如下四种隔离级别：

1. Read uncommitted  *读未提交*， 在该级别下，一个事务对一行数据进行修改的过程，不允许另一个事务对该数据进行修改，但允许另一个事务该行数据进行读取。因此本级别下，**不会出现更新不见，但会出现脏读、不可重复度**

2. Read uncommitted *读提交* ，该级别下，未提交的写事务不允许其他事务访问该行，因此*不会出现脏读*；但是读取数据的事务允许其他事务的访问该行数据，因此*会出现不可重复读*的情况。

3. Repeatable read *重复读* 在该级别下， 读事务禁止写事务， 但是允许读事务，因此不会出现同一个事务两次读到不同的数据到情况(**解决了不可重复读，意思是可以重复读取情况**)，并且写事务禁止其他一切事务

4. Serializable 序列化 该级别要求所有事务都必须**串行执行**，因此能避免一切因并发引起的问题，**但效率很低**。





   隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

| 隔离级别                   | 脏读   | 不可重复读 | 幻读   |
| -------------------------- | ------ | ---------- | ------ |
| 未提交读(Read uncommitted) | 可能   | 可能       | 可能   |
| 已提交读(Read committed）  | 不可能 | 可能       | 可能   |
| 可重复读(Repeatable read） | 不可能 | 不可能     | 肯能   |
| 可串行化（Serializable ）  | 不可能 | 不可能     | 不可能 |


#简单的区别
1. 所谓幻读，是指事务A读取与搜索条件相匹配的若干行。事务B以插入或删除行等方式来修改事务A的结果集，然后再提交。
所谓幻读是由于插入和删除造成的

# 如何理解并记忆数据库的四种隔离性质
1. 什么叫做事务隔？
> 说白了就是几个事务之前能不能看到对方操作的结果,比如两个事务并行执行

2. 对应的隔离级别？
   - 读未提交  
        - 所有事务都可以看到其他未提交事务的执行结果， 
        - 所以这个读未提交是可能导致脏读的
    - 读已提交 
        - 所有事务都可以看到其他已经提交事务的执行结果， 
        - 多个事务都提交了，导致结果不一样，所有会导致不可重复读的情况发生
    - 可重复读 
        - 它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行(加锁，读读操作可以并发执行， 读写不可用(避免读到不一致的数据))
    -  可串行  
        - 就是指事务执行完一个才能接着执行下一个，这种情况下并发性最低，它通过强制事务排序，使之不可能相互冲突
        
        
# 事务的四个隔离级别是如何做的？

关于这个问题该怎么回答？
主要从锁和MVCC 这两个机制来回答，以及 不同隔离级别下面或者使用的锁方式



是采用锁机制还是采用 MVCC 多版本控制机制， 


MVCC 重要的是DB_TRI_ID 该条记录的事务版本号, DB_ROLL_ID回滚指针事务号从最旧指向最新的，形成一条事务链，,

在读取的时候，通过 当前事务号和 DB_ROLL_ID当中的事务链进行一个对比，提交结果 , 并且

1. 锁的种类
 间隙锁， 行锁记录锁， next-key lock记录加间隙锁 ，
 
 
RR隔离级别有时还会添加Gap锁。 RR隔离级别主要是解决不可重复读和幻读，因此要加行锁和间隙锁配合使用


1. 读操作是添加共享锁
2. 写操作是互斥锁，

关键就看行共享锁还是行互斥锁这两个东西，

串行化都是直接加表级别的锁的，