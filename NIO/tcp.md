# nagle

# tcp和udp对粘包拆包机制的影响

1. UDP是基于报文发送的，从UDP的帧结构可以看出，在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。

2. TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。


注意tcp 和udp 当中首部长度和数据长度是两个概念

1. tcp有 首部长度，但是没有数据长度
2. udp 有数据包的明确长度

# TCP粘包的原因


1. tcp面向字节流，没有边界


2. udp面向数据报，数据包有边界条件。（**UDP不会出现粘包，因为它有消息边界(**）
3. tcp为提高性能，发送端会将需要发送的数据发送到缓冲区，等待缓冲区满了之后，再将缓冲中的数据发送到接收方。同理，接收方也有缓冲区这样的机制，来接收数据。（**固定大小的缓冲区**）


linux 当中为了避免多次的RTT，如果数据包很小也用一次小包发送，这样会导致RTT 很多个，所以采用


发生TCP粘包、拆包主要是由于下面一些原因：


-  应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。

-  应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。

-  进行mss（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度>mss的时候将发生拆包。

-  接收方法不及时读取套接字缓冲区数据，这将发生粘包。(积累多了才今进行统一的处理)

# 接收端
由于消息分散在不同的数据包当中，接受端很难去区分开来，没有明确的边界添加

# 如何解决
TCP自身是没有机制处理粘包和拆包问题的，只能依靠外部处理，常用的有下面几种情况

1. 发送方在数据包前面增加字段，表明tcp当中数据包的长度，这样就可以像UDP一样了


2. 发送方可以在在数据包之间设置边界，如添加特殊符号\n，这样，接收端通过这个边界就可以将不同的数据包拆分开。

3. 设置定长消息，每个消息的长度固定，长度不够的使用0填充。



[tcp粘包和拆包的处理方案](https://blog.csdn.net/feng020a/article/details/60587726)


# 基于套接字的编程

# 参考链接
[TCP粘包问题分析和解决（全)](https://blog.csdn.net/ljwy1234/article/details/79518090)


